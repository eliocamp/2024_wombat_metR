---
title: "Read, manipulate and plot gridded data with metR"
author: 
  - name: "Elio Campitelli"
    affiliation: "Monash University"
subtitle: "Open the World with Open Source, WOMBAT 2024"
title-slide-attributes:
  data-background-image: "img/title.png"
  data-background-size: contain
  data-background-opacity: "0.35"
  data-background-position: 50% 600%
execute:
  echo: true
  cache: true
highlight-style: solarized
format: 
  revealjs:
    width: 1500
    height: 768
    theme: 
      - custom_slides.scss
---

```{r setup}
#| echo: false
#| cache: false

knitr::opts_chunk$set(fig.align = "center", tidy = FALSE)
library(metR)
library(data.table)
library(ggplot2)
library(tidyfast)

Sys.setenv(TZ = 'GMT')
```

# Reading data {background-image="img/mosaico-half.png" background-position="right" background-size="contain" background-opacity="1"}

----

```{r}
#| cache: false
knitr::knit_exit()
```

We are going to use ERA5 data, which is weather data on a regular grid.
The data is in a NetCDF file.

```{r era5_sst}
era5_sst <- "data/era_sst.nc"
```

. . . 

```{r glance-era5_sst}
era5_sst |> 
  metR::GlanceNetCDF() # <1>
```

1. Access file metadata


---

We can read one variable with `ReadNetCDF()`

```{r sst}
sst <- era5_sst |> 
  metR::ReadNetCDF(vars = "sst") # <1>
```

1. Read only the sst variable

By default, the result is a data.table.

```{r head-sst}
head(na.omit(sst))
```

---- 

We can take a look at one slice of the data by subsetting the first time and plotting with `geom_contour_fill()` 

```{r look-sst}
#| code-line-numbers: "|2|4"
sst |> 
  _[time == time[1]] |> 
  ggplot(aes(lon, lat)) +
  metR::geom_contour_fill(aes(z = sst))
```

----

```{r monthly-mean-sst}
#| code-line-numbers: "|2"
sst |> 
  _[, .(mean = mean(sst)), by = .(lon, lat, month(time))] |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = mean)) +
  facet_wrap(~ month)
```

---

We can also add a column with the departures from that climatological cycle. 

```{r anomalies-sst}
sst <- sst[, sst_a := sst - mean(sst, na.rm = TRUE),
           by = .(lon, lat, month(time))]
```

```{r jan1998-sst-viridis}
#| code-line-numbers: "|2"
sst |> 
  _[time == as.POSIXct("1998-01-01")] |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = sst_a))
```

---


```{r jan1998-sst-viridis2}
#| echo: false
<<jan1998-sst-viridis>>
```

Where's the zero?

----

<!-- Anomalies are centered at zero, so when plotting them, it's a good idea to use a divergent scale (`scale_fill_divergent()`) and center contour breaks at zero, also excluding the zero break to highligh positive and negative areas.  -->

```{r jan1998-sst-div}
#| code-line-numbers: "|5"
sst |> 
  _[time == as.POSIXct("1998-01-01")] |>  
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = sst_a)) +
  metR::scale_fill_divergent() 
```

---

<!-- One issue with this plot is that the breaks in the colour legend are independent of the contour breaks, so it's not easy to actually know the value that each colour represents.  -->
<!-- We can use the `level` computed variable, which is a discrete variable  -->


```{r jan1998-sst-discretised}
#| code-line-numbers: "|5|6"
sst |> 
  _[time == as.POSIXct("1998-01-01")] |>  
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = sst_a, 
                        fill = after_stat(level))) + 
  metR::scale_fill_divergent_discretised()
```

<!-- 1. Map fill to level; which is a discrete (factor) variable computed by `geom_contour_fill()`. -->
<!-- 2. Use discretised scale, which understands the factors' format to create a 'continuous' scale with the correct breaks.  -->

---

```{r jan1998-sst-anchor}
#| code-line-numbers: "|5"
sst |> 
  _[time == as.POSIXct("1998-01-01")] |>  
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = sst_a, fill = after_stat(level)),
                    breaks = metR::AnchorBreaks(anchor = 0, exclude = 0)) + 
  scale_fill_divergent_discretised()


```

---

::: {.notes}

Finally, one of my favourite tricks to give contours a bit of flair is to use illuminated contours. 

:::

```{r jan1998-sst-tanaka}
#| code-line-numbers: "|6,7"
sst |> 
  _[time == as.POSIXct("1998-01-01")] |>  
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = sst_a, fill = after_stat(level)),
                    breaks = AnchorBreaks(anchor = 0, exclude = 0)) + 
  metR::geom_contour_tanaka(aes(z = sst_a),
                            breaks = AnchorBreaks(anchor = 0, exclude = 0)) +
  scale_fill_divergent_discretised()
```

::: {.notes}

I picked 1998 because it was a special year with a monster El NiÃ±o. 
This is a very important mode of variability that we might want to study. 
One way of analysing it is using Principal Component Analysis, also known as EOF in the climate sciences. 

:::


---

We can compute the EOFs of SST with the `EOF()`

```{r ensoregion}
#| echo: false
sst |> 
  _[time == as.POSIXct("1998-01-01")] |>  
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = sst_a, fill = after_stat(level)),
                    breaks = AnchorBreaks(anchor = 0, exclude = 0)) + 
  geom_contour_tanaka(aes(z = sst_a),
                      breaks = AnchorBreaks(anchor = 0, exclude = 0)) +
  scale_fill_divergent_discretised() +
  annotate("rect", 
           xmin = 150, xmax = 280,
           ymin = -10, ymax = 10,
           fill = NA, colour = "black")
```

```{r eofs}
#| code-line-numbers: "|2|3|4|5|6"
sst_eofs <- sst |>
  _[lon %between% c(150, 280) & lat %between% c(-10, 10)] |>
  na.omit() |>
  _[, sst_a := sst_a*sqrt(cos(lat*pi/180))] |>  
  metR::EOF(sst_a ~ time | lon + lat, 
            n = 1:10, 
            data = _) 
```

---

```{r peek-eofs-sdev}
sst_eofs$sdev  
```

---

```{r peek-eofs-left}
sst_eofs$left
```

---

```{r peek-eofs-right}
sst_eofs$right
```

---

Quick look with `screeplot()`: 

```{r screeplot}
screeplot(sst_eofs)
```


---

```{r spatial-eofs-hl}
#| code-line-numbers: "|2|3|9"
sst_eofs |> 
  cut(1:2) |> 
  _$right |> 
  ggplot(aes(lon, lat)) + 
  geom_contour_fill(aes(z = sst_a), 
                    breaks = AnchorBreaks(0, binwidth = 0.02, exclude = 0)) +
  scale_fill_divergent() +
  facet_wrap(~ PC, ncol = 1) +
  tagger::tag_facets()
```

---

Rotate EOFs with the `rotate` argument. 

```{r eofs-varimax}
#| code-line-numbers: "|6"
sst_eofs <- sst |>
  _[lon %between% c(150, 280) & lat %between% c(-10, 10)] |> 
  na.omit() |> 
  _[, sst_a := sst_a*sqrt(cos(lat*pi/180))] |> 
  EOF(sst_a ~ time | lon + lat, n = 1:10, data = _, 
      rotate = stats::varimax) 
```

---

::: {.notes}
After rotation, the first and second component share a greater percentage of the variance. 
:::

```{r screeplot-varimax}
screeplot(sst_eofs)
```

---

```{r spatial-varimax}
sst_eofs |> 
  cut(1:2) |> 
  _$right |> 
  ggplot(aes(lon, lat)) + 
  geom_contour_fill(aes(z = sst_a), breaks = AnchorBreaks(0, exclude = 0)) +
  scale_fill_divergent() +
  facet_wrap(~ PC) +
  tagger::tag_facets()
```

---

Add continents as reference. 
Quick trick: draw zero contour of topography. 

```{r topo}
topo <- ReadNetCDF("data/topo.nc")
```

```{r eofs-topo} 
#| code-line-numbers: "|4"
cut(sst_eofs, 1:2)$right |> 
  ggplot(aes(lon, lat)) + 
  geom_contour_fill(aes(z = sst_a), breaks = AnchorBreaks(0, exclude = 0)) +
  geom_contour2(data = topo, aes(z = topo), breaks = 0) +
  scale_fill_divergent() +
  facet_wrap(~ PC)
```


---

So now we have our ENSO time series, so we can ask questions such as, how does ENSO affect the atmosphere? 
I'm going to look at geopotential height and precipitation in and around South America. 

So first read the variables

```{r era5_variables}
era5_variables <- "data/era5_variables.nc"
```

```{r glance-era5_variables}
era5_variables |> 
  GlanceNetCDF()
```

---

```{r era5_vars}
#| code-line-numbers: "|2|3,4"
era5_vars <- era5_variables |> 
  ReadNetCDF(vars = c(pp = "tp", "z"), 
             subset = list(lon = c(180, 360), 
                           lat= c(-90, -10))) 
```

And I will reshape this into a long dataset and compute monthly anomalies for each one. 

```{r era5_vars-long, cache=FALSE}
era5_vars <- era5_vars |> 
  dt_pivot_longer(cols = z:pp) |> 
  _[, value_a := value - mean(value), by = .(lon, lat, month(time), name)]
head(era5_vars)
```

---

::: {.notes}
Because research suggests that the location of ENSO anomalies is important to understand the impact of ENSO, I'm going to to a multivariate linear regression using the first two PCs. 
So first we cut the EOF to keep only the first 2, reshape into wide, and then join with our dataset before doing a lienar regression at each point and also for each season.
`FitLm()` is a wrapper around `stats::.lm.fit()`; we need to use this instead of regular old `lm()` because `lm()` is very slow at parsing the formula interface.
:::

```{r regression}
#| code-line-numbers: "|4|5"
regression <- cut(sst_eofs, 1:2)$left |> 
  dt_pivot_wider(names_from = PC, values_from = sst_a) |> 
  era5_vars[i = _, on = .NATURAL, allow.cartesian = TRUE] |> 
  _[, metR::FitLm(value_a, PC1, PC2),
    by = .(lon, lat, season = metR::season(time), name)]
```

---

::: {.notes}
For expediency, let's look only at Spring ("September-October-November"):
:::

```{r regression_spring}
regression_spring <- regression |> 
  _[season == "SON"] |> 
  _[term != "(Intercept)"] 
```

```{r regression_spring-base}
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate)) +
  geom_contour2(data = topo[lon %between% c(180, 360) & lat %between% c(-90, -10)],
                aes(z = topo), breaks = 0) +
  scale_fill_divergent() +
  facet_grid(term ~ name)
```

---

::: {.notes}

The problem here is that precipitation and geopotential height are in completely differnet units so we cannot represent both in the same colour scale. 
We could use different colour scales using ggnewscale, but I'm going to plot one variable with filled contours and the other with regular lines. 
To know the value of each contour, I'm going to use the `label` aesthetic to print the level

:::

```{r regression_spring-wider}
regression_spring <- regression_spring |> 
  dt_pivot_wider(names_from = name, values_from = estimate)

geom_topo <-   geom_contour2(data = topo[lon %between% c(180, 360) & lat %between% c(-90, -10)],
                             aes(z = topo), breaks = 0) 
```

---

```{r regression_spring-contours}
#| code-line-numbers: "|5|6"
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = pp)) +
  geom_contour2(aes(z = z/9.8, 
                    linetype = after_stat(factor(sign(-level))), 
                    label = after_stat(level))) +
  geom_topo +
  scale_fill_divergent() +
  facet_wrap(~term, ncol = 1)
```

---

::: {.notes}
This way we can see the interaction between the circulation and precipitation effect of ENSO. 
An alternative way to look at geopotential height is to use the Geostrophic Wind approximation. 
In the mid latitudes, the wind goes righly paralel to geopotential contours and clockwise around negative anomalies. 
We can compute this circulation with `GeostrophicWind()`. 
Because we are plotting in latlon coordinates, we then need to transform the wind vectors from physical uints to lonlat units with `dlon` and `dlat`. 
Finally, we plot the vectors with `geom_vector()`. 
:::

```{r regression_spring-geostrophic}
#| code-line-numbers: "|2|3"
regression_spring <- regression_spring |> 
  _[, c("u", "v") := metR::GeostrophicWind(z, lon, lat), by = .(term)] |> 
  _[, c("dlon", "dlat") := list(metR::dlon(u, lat), metR::dlat(v))]
```

---

```{r regression_spring-vectors}
#| code-line-numbers: "|4,5"
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = pp)) +
  metR::geom_vector(aes(dx = dlon, dy = dlat), skip = 4) +
  metR::scale_mag() +
  geom_topo +
  scale_fill_divergent() +
  facet_wrap(~term, ncol = 1)
```

---

::: {.notes}
An alternative that I like is to use `geom_streamline()`. 
This draws lines that follow the flow of the vector field: 
:::

```{r regression_spring-streamlines}
#| code-line-numbers: "|4,5"
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = pp)) +
  metR::geom_streamline(aes(dx = dlon , dy = dlat),
                        skip = 5, L = 30) +
  geom_topo +
  scale_fill_divergent() +
  facet_wrap(~term, ncol = 1)
```

---

::: {.notes}
And to add more flair (and clarity, IMHO), we can remove the arrows and signal the direction of the streamlines by mapping the linewidth to the `step` computed variable, which goes from 0 to the number of steps in the line (in this case to the forth power to make the effect more dramatic).
:::

```{r regression_spring-streamdrops}
#| code-line-numbers: "|5,6,7,8"
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = pp)) +
  geom_streamline(aes(dx = dlon , dy = dlat, 
                      linewidth = after_stat(step^4)),
                  arrow = NULL,
                  skip = 5, L = 30) +
  scale_linewidth(range = c(0.01, 0.6), guide = "none") +
  geom_topo +
  scale_fill_divergent() +
  facet_wrap(~term, ncol = 1)
```

---

::: {.notes}
So now we can start with the details. 
The x and y axis can be printed nicer with `scale_x_longitude()` and `scale_y_latitude()`, which are thin wrappers around continuous scale with common defaults appropriate for these dimensions. 
:::


```{r regression_spring-flair}
#| code-line-numbers: "|14,15|11,12"
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = pp, fill = after_stat(level)), 
                    breaks = AnchorBreaks(0, exclude = 0)) +
  geom_streamline(aes(dx = dlon , dy = dlat, 
                      linewidth = after_stat(step^4)),
                  arrow = NULL,
                  skip = 5, L = 30) +
  scale_linewidth(range = c(0.01, 0.6), guide = "none") +
  geom_topo +
  scale_fill_divergent_discretised(low = scales::muted("orange"), 
                                   high = scales::muted("green")) +
  facet_wrap(~term, ncol = 2) +
  metR::scale_x_longitude() +
  metR::scale_y_latitude()  +
  coord_quickmap()
```

---

```{r}
#| echo: false
regression_spring |> 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = pp, fill = after_stat(level)),
                    breaks = AnchorBreaks(0, exclude = 0)) +
  geom_streamline(aes(dx = dlon , dy = dlat, 
                      linewidth = after_stat(step^4)),
                  arrow = NULL,
                  skip = 5, L = 30) +
  scale_linewidth(range = c(0.01, 0.6), guide = "none") +
  geom_topo +
  scale_fill_divergent_discretised("Precipitation", 
                                   low = scales::muted("orange"), 
                                   high = scales::muted("green"),
                                   guide = guide_colorsteps(even.steps = FALSE)) +
  facet_wrap(~term, ncol = 2) +
  scale_x_longitude() +
  scale_y_latitude()  +
  coord_quickmap() +
  theme_minimal() +
  theme(legend.position = "bottom", 
        legend.title.position = "top", 
        legend.title = element_text(hjust = 0.5),
        legend.key.width = grid::unit(1, "null"),
        legend.frame = element_rect(colour = "black", linewidth = 0.1),
        legend.key.height = grid::unit(0.5, "lines"))
```

---

# Thanks! {background-image="img/logo.png" background-position="85% 50%" background-size=500px background-opacity="1"}

[eliocamp.github.io/metR/](https://eliocamp.github.io/metR/)

[eliocamp.github.io/](https://eliocamp.github.io/)


